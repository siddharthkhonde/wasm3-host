/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const M3_VERSION_MAJOR: u32 = 0;
pub const M3_VERSION_MINOR: u32 = 4;
pub const M3_VERSION_REV: u32 = 7;
pub const M3_VERSION: &'static [u8; 6usize] = b"0.4.7\0";
pub const M3_COMPILER_CLANG: u32 = 1;
pub const M3_ARCH: &'static [u8; 7usize] = b"x86_64\0";
pub type size_t = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type M3Result = *const cty::c_char;
pub type IM3Environment = *mut M3Environment;
pub type IM3Runtime = *mut M3Runtime;
pub type IM3Module = *mut M3Module;
pub type IM3Function = *mut M3Function;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3ErrorInfo {
    pub result: M3Result,
    pub runtime: IM3Runtime,
    pub module: IM3Module,
    pub function: IM3Function,
    pub file: *const cty::c_char,
    pub line: u32,
    pub message: *const cty::c_char,
}
pub mod _bindgen_ty_1 {
    pub type Type = u32;
    pub const c_m3Type_none: Type = 0;
    pub const c_m3Type_i32: Type = 1;
    pub const c_m3Type_i64: Type = 2;
    pub const c_m3Type_f32: Type = 3;
    pub const c_m3Type_f64: Type = 4;
    pub const c_m3Type_void: Type = 5;
    pub const c_m3Type_ptr: Type = 6;
    pub const c_m3Type_trap: Type = 7;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3ImportInfo {
    pub moduleUtf8: *const cty::c_char,
    pub fieldUtf8: *const cty::c_char,
}
pub type IM3ImportInfo = *mut M3ImportInfo;
extern "C" {
    pub static mut m3Err_none: M3Result;
}
extern "C" {
    pub static mut m3Err_typeListOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_mallocFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_incompatibleWasmVersion: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMalformed: M3Result;
}
extern "C" {
    pub static mut m3Err_misorderedWasmSection: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmOverrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMissingInitExpr: M3Result;
}
extern "C" {
    pub static mut m3Err_lebOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_missingUTF8: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmSectionUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmSectionOverrun: M3Result;
}
extern "C" {
    pub static mut m3Err_invalidTypeId: M3Result;
}
extern "C" {
    pub static mut m3Err_tooManyMemorySections: M3Result;
}
extern "C" {
    pub static mut m3Err_moduleAlreadyLinked: M3Result;
}
extern "C" {
    pub static mut m3Err_functionLookupFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_functionImportMissing: M3Result;
}
extern "C" {
    pub static mut m3Err_malformedFunctionSignature: M3Result;
}
extern "C" {
    pub static mut m3Err_funcSignatureMissingReturnType: M3Result;
}
extern "C" {
    pub static mut m3Err_noCompiler: M3Result;
}
extern "C" {
    pub static mut m3Err_unknownOpcode: M3Result;
}
extern "C" {
    pub static mut m3Err_functionStackOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_functionStackUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_mallocFailedCodePage: M3Result;
}
extern "C" {
    pub static mut m3Err_settingImmutableGlobal: M3Result;
}
extern "C" {
    pub static mut m3Err_optimizerFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_missingCompiledCode: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMemoryOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_globalMemoryNotAllocated: M3Result;
}
extern "C" {
    pub static mut m3Err_globaIndexOutOfBounds: M3Result;
}
extern "C" {
    pub static mut m3Err_argumentCountMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_trapOutOfBoundsMemoryAccess: M3Result;
}
extern "C" {
    pub static mut m3Err_trapDivisionByZero: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIntegerOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIntegerConversion: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIndirectCallTypeMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_trapTableIndexOutOfRange: M3Result;
}
extern "C" {
    pub static mut m3Err_trapTableElementIsNull: M3Result;
}
extern "C" {
    pub static mut m3Err_trapExit: M3Result;
}
extern "C" {
    pub static mut m3Err_trapAbort: M3Result;
}
extern "C" {
    pub static mut m3Err_trapUnreachable: M3Result;
}
extern "C" {
    pub static mut m3Err_trapStackOverflow: M3Result;
}
extern "C" {
    pub fn m3_NewEnvironment() -> IM3Environment;
}
extern "C" {
    pub fn m3_FreeEnvironment(i_environment: IM3Environment);
}
extern "C" {
    pub fn m3_NewRuntime(
        io_environment: IM3Environment,
        i_stackSizeInBytes: u32,
        unused: *mut cty::c_void,
    ) -> IM3Runtime;
}
extern "C" {
    pub fn m3_FreeRuntime(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_GetMemory(
        i_runtime: IM3Runtime,
        o_memorySizeInBytes: *mut u32,
        i_memoryIndex: u32,
    ) -> *mut u8;
}
extern "C" {
    pub fn m3_ParseModule(
        i_environment: IM3Environment,
        o_module: *mut IM3Module,
        i_wasmBytes: *const u8,
        i_numWasmBytes: u32,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_FreeModule(i_module: IM3Module);
}
extern "C" {
    pub fn m3_LoadModule(io_runtime: IM3Runtime, io_module: IM3Module) -> M3Result;
}
pub type M3RawCall = ::core::option::Option<
    unsafe extern "C" fn(
        runtime: IM3Runtime,
        _sp: *mut u64,
        _mem: *mut cty::c_void,
    ) -> *const cty::c_void,
>;
extern "C" {
    pub fn m3_LinkRawFunction(
        io_module: IM3Module,
        i_moduleName: *const cty::c_char,
        i_functionName: *const cty::c_char,
        i_signature: *const cty::c_char,
        i_function: M3RawCall,
    ) -> M3Result;
}
pub type M3RawCallEx = ::core::option::Option<
    unsafe extern "C" fn(
        runtime: IM3Runtime,
        _sp: *mut u64,
        _mem: *mut cty::c_void,
        cookie: *mut cty::c_void,
    ) -> *const cty::c_void,
>;
extern "C" {
    pub fn m3_LinkRawFunctionEx(
        io_module: IM3Module,
        i_moduleName: *const cty::c_char,
        i_functionName: *const cty::c_char,
        i_signature: *const cty::c_char,
        i_function: M3RawCallEx,
        i_cookie: *mut cty::c_void,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_Yield() -> M3Result;
}
extern "C" {
    pub fn m3_FindFunction(
        o_function: *mut IM3Function,
        i_runtime: IM3Runtime,
        i_functionName: *const cty::c_char,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_Call(i_function: IM3Function) -> M3Result;
}
extern "C" {
    pub fn m3_CallWithArgs(
        i_function: IM3Function,
        i_argc: u32,
        i_argv: *const *const cty::c_char,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_GetErrorInfo(i_runtime: IM3Runtime, info: *mut M3ErrorInfo);
}
extern "C" {
    pub fn m3_ResetErrorInfo(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_PrintRuntimeInfo(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_PrintM3Info();
}
extern "C" {
    pub fn m3_PrintProfilerInfo();
}
pub type m3ret_t = *const cty::c_void;
pub type cstr_t = *const cty::c_char;
pub type ccstr_t = *const cty::c_char;
pub type bytes_t = *const u8;
pub type cbytes_t = *const u8;
pub type m3opcode_t = u16;
pub type m3reg_t = i64;
pub type m3slot_t = u32;
pub type m3stack_t = *mut m3slot_t;
pub type code_t = *mut cty::c_void;
pub type pc_t = *const code_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3MemoryHeader {
    pub runtime: IM3Runtime,
    pub maxStack: *mut cty::c_void,
    pub length: size_t,
}
#[repr(C)]
pub struct M3CodePageHeader {
    pub next: *mut M3CodePage,
    pub lineIndex: u32,
    pub numLines: u32,
    pub sequence: u32,
    pub usageCount: u32,
}
extern "C" {
    pub fn m3_Malloc(o_ptr: *mut *mut cty::c_void, i_size: size_t) -> M3Result;
}
extern "C" {
    pub fn m3_Realloc(
        io_ptr: *mut *mut cty::c_void,
        i_newSize: size_t,
        i_oldSize: size_t,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_Free(io_ptr: *mut *mut cty::c_void);
}
extern "C" {
    pub fn m3_CopyMem(
        o_to: *mut *mut cty::c_void,
        i_from: *const cty::c_void,
        i_size: size_t,
    ) -> M3Result;
}
extern "C" {
    pub fn NormalizeType(o_type: *mut u8, i_convolutedWasmType: i8) -> M3Result;
}
extern "C" {
    pub fn IsIntType(i_wasmType: u8) -> bool;
}
extern "C" {
    pub fn IsFpType(i_wasmType: u8) -> bool;
}
extern "C" {
    pub fn Is64BitType(i_m3Type: u8) -> bool;
}
extern "C" {
    pub fn SizeOfType(i_m3Type: u8) -> u32;
}
extern "C" {
    pub fn Read_u64(o_value: *mut u64, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_u32(o_value: *mut u32, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_f64(o_value: *mut f64, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_f32(o_value: *mut f32, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_u8(o_value: *mut u8, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLebUnsigned(
        o_value: *mut u64,
        i_maxNumBits: u32,
        io_bytes: *mut bytes_t,
        i_end: cbytes_t,
    ) -> M3Result;
}
extern "C" {
    pub fn ReadLebSigned(
        o_value: *mut i64,
        i_maxNumBits: u32,
        io_bytes: *mut bytes_t,
        i_end: cbytes_t,
    ) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_u32(o_value: *mut u32, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_u7(o_value: *mut u8, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i7(o_value: *mut i8, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i32(o_value: *mut i32, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i64(o_value: *mut i64, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_utf8(o_utf8: *mut cstr_t, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn SPrintArg(
        o_string: *mut cty::c_char,
        i_n: size_t,
        i_sp: m3stack_t,
        i_type: u8,
    ) -> size_t;
}
extern "C" {
    pub fn ReportError(
        io_runtime: IM3Runtime,
        i_module: IM3Module,
        i_function: IM3Function,
        i_errorMessage: ccstr_t,
        i_file: ccstr_t,
        i_lineNum: u32,
    );
}
pub type IM3Operation = ::core::option::Option<
    unsafe extern "C" fn(
        _pc: pc_t,
        _sp: m3stack_t,
        _mem: *mut M3MemoryHeader,
        _r0: m3reg_t,
        _fp0: f64,
    ) -> m3ret_t,
>;
#[repr(C)]
pub struct M3CodePage {
    pub info: M3CodePageHeader,
    pub code: [code_t; 1usize],
}
pub type IM3CodePage = *mut M3CodePage;
extern "C" {
    pub fn NewCodePage(i_minNumLines: u32) -> IM3CodePage;
}
extern "C" {
    pub fn FreeCodePages(io_list: *mut IM3CodePage);
}
extern "C" {
    pub fn NumFreeLines(i_page: IM3CodePage) -> u32;
}
extern "C" {
    pub fn GetPageStartPC(i_page: IM3CodePage) -> pc_t;
}
extern "C" {
    pub fn GetPagePC(i_page: IM3CodePage) -> pc_t;
}
extern "C" {
    pub fn EmitWord_impl(i_page: IM3CodePage, i_word: *mut cty::c_void);
}
extern "C" {
    pub fn EmitWord32(i_page: IM3CodePage, i_word: u32);
}
extern "C" {
    pub fn EmitWord64(i_page: IM3CodePage, i_word: u64);
}
extern "C" {
    pub fn PushCodePage(io_list: *mut IM3CodePage, i_codePage: IM3CodePage);
}
extern "C" {
    pub fn PopCodePage(io_list: *mut IM3CodePage) -> IM3CodePage;
}
extern "C" {
    pub fn GetEndCodePage(i_list: IM3CodePage) -> IM3CodePage;
}
extern "C" {
    pub fn CountCodePages(i_list: IM3CodePage) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3BranchPatch {
    pub next: *mut M3BranchPatch,
    pub location: *mut pc_t,
}
pub type IM3BranchPatch = *mut M3BranchPatch;
#[repr(C)]
pub struct M3CompilationScope {
    pub outer: *mut M3CompilationScope,
    pub pc: pc_t,
    pub patches: IM3BranchPatch,
    pub depth: i32,
    pub initStackIndex: i16,
    pub type_: u8,
    pub opcode: m3opcode_t,
    pub isPolymorphic: bool,
}
pub type IM3CompilationScope = *mut M3CompilationScope;
#[repr(C)]
pub struct M3Compilation {
    pub runtime: IM3Runtime,
    pub module: IM3Module,
    pub wasm: bytes_t,
    pub wasmEnd: bytes_t,
    pub block: M3CompilationScope,
    pub function: IM3Function,
    pub page: IM3CodePage,
    pub releasedPatches: IM3BranchPatch,
    pub numEmits: u32,
    pub numOpcodes: u32,
    pub firstDynamicStackIndex: u16,
    pub stackIndex: u16,
    pub firstConstSlotIndex: u16,
    pub maxConstSlotIndex: u16,
    pub firstLocalSlotIndex: u16,
    pub firstDynamicSlotIndex: u16,
    pub constants: [m3slot_t; 120usize],
    pub wasmStack: [u16; 2000usize],
    pub typeStack: [u8; 2000usize],
    pub m3Slots: [u8; 4000usize],
    pub maxAllocatedSlotPlusOne: u16,
    pub regStackIndexPlusOne: [u16; 2usize],
    pub previousOpcode: m3opcode_t,
}
pub type IM3Compilation = *mut M3Compilation;
pub type M3Compiler = ::core::option::Option<
    unsafe extern "C" fn(arg1: IM3Compilation, arg2: m3opcode_t) -> M3Result,
>;
#[repr(C)]
pub struct M3OpInfo {
    pub stackOffset: i8,
    pub type_: u8,
    pub operations: [IM3Operation; 4usize],
    pub compiler: M3Compiler,
}
pub type IM3OpInfo = *const M3OpInfo;
extern "C" {
    pub fn GetTypeNumSlots(i_type: u8) -> u16;
}
extern "C" {
    pub fn AlignSlotIndexToType(io_slotIndex: *mut u16, i_type: u8);
}
extern "C" {
    pub fn IsRegisterAllocated(o: IM3Compilation, i_register: u32) -> bool;
}
extern "C" {
    pub fn IsRegisterLocation(i_location: i16) -> bool;
}
extern "C" {
    pub fn IsFpRegisterLocation(i_location: i16) -> bool;
}
extern "C" {
    pub fn IsIntRegisterLocation(i_location: i16) -> bool;
}
extern "C" {
    pub fn IsStackPolymorphic(o: IM3Compilation) -> bool;
}
extern "C" {
    pub fn CompileBlock(io: IM3Compilation, i_blockType: u8, i_blockOpcode: u8) -> M3Result;
}
extern "C" {
    pub fn Compile_BlockStatements(io: IM3Compilation) -> M3Result;
}
extern "C" {
    pub fn Compile_Function(io_function: IM3Function) -> M3Result;
}
extern "C" {
    pub fn GetMaxUsedSlotPlusOne(o: IM3Compilation) -> u16;
}
extern "C" {
    pub fn m3_LinkLibC(io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn m3_LinkSpecTest(io_module: IM3Module) -> M3Result;
}
#[repr(C)]
pub struct M3FuncType {
    pub next: *mut M3FuncType,
    pub numArgs: u32,
    pub returnType: u8,
    pub argTypes: [u8; 3usize],
}
pub type IM3FuncType = *mut M3FuncType;
extern "C" {
    pub fn AllocFuncType(o_functionType: *mut IM3FuncType, i_numArgs: u32) -> M3Result;
}
extern "C" {
    pub fn AreFuncTypesEqual(i_typeA: IM3FuncType, i_typeB: IM3FuncType) -> bool;
}
#[repr(C)]
pub struct M3Function {
    pub module: *mut M3Module,
    pub import: M3ImportInfo,
    pub wasm: bytes_t,
    pub wasmEnd: bytes_t,
    pub name: cstr_t,
    pub funcType: IM3FuncType,
    pub compiled: pc_t,
    pub maxStackSlots: u16,
    pub numArgSlots: u16,
    pub numLocals: u16,
    pub numLocalBytes: u16,
    pub constants: *mut cty::c_void,
    pub numConstantBytes: u16,
    pub ownsWasmCode: bool,
}
extern "C" {
    pub fn Function_Release(i_function: IM3Function);
}
extern "C" {
    pub fn Function_FreeCompiledCode(i_function: IM3Function);
}
extern "C" {
    pub fn GetFunctionImportModuleName(i_function: IM3Function) -> cstr_t;
}
extern "C" {
    pub fn GetFunctionName(i_function: IM3Function) -> cstr_t;
}
extern "C" {
    pub fn GetFunctionNumArgs(i_function: IM3Function) -> u32;
}
extern "C" {
    pub fn GetFunctionNumReturns(i_function: IM3Function) -> u32;
}
extern "C" {
    pub fn GetFunctionReturnType(i_function: IM3Function) -> u8;
}
extern "C" {
    pub fn GetFunctionNumArgsAndLocals(i_function: IM3Function) -> u32;
}
extern "C" {
    pub fn SPrintFunctionArgList(i_function: IM3Function, i_sp: m3stack_t) -> cstr_t;
}
#[repr(C)]
pub struct M3MemoryInfo {
    pub initPages: u32,
    pub maxPages: u32,
}
#[repr(C)]
pub struct M3Memory {
    pub mallocated: *mut M3MemoryHeader,
    pub numPages: u32,
    pub maxPages: u32,
}
pub type IM3Memory = *mut M3Memory;
#[repr(C)]
pub struct M3DataSegment {
    pub initExpr: *const u8,
    pub data: *const u8,
    pub initExprSize: u32,
    pub memoryRegion: u32,
    pub size: u32,
}
extern "C" {
    pub fn FreeImportInfo(i_info: *mut M3ImportInfo);
}
#[repr(C)]
pub struct M3Global {
    pub import: M3ImportInfo,
    pub __bindgen_anon_1: M3Global__bindgen_ty_1,
    pub initExpr: bytes_t,
    pub initExprSize: u32,
    pub type_: u8,
    pub imported: bool,
    pub isMutable: bool,
}
#[repr(C)]
pub struct M3Global__bindgen_ty_1 {
    pub intValue: __BindgenUnionField<i64>,
    pub f64Value: __BindgenUnionField<f64>,
    pub f32Value: __BindgenUnionField<f32>,
    pub bindgen_union_field: u64,
}
pub type IM3Global = *mut M3Global;
#[repr(C)]
pub struct M3Module {
    pub runtime: *mut M3Runtime,
    pub environment: *mut M3Environment,
    pub name: cstr_t,
    pub numFuncTypes: u32,
    pub funcTypes: *mut IM3FuncType,
    pub numImports: u32,
    pub imports: *mut IM3Function,
    pub numFunctions: u32,
    pub functions: *mut M3Function,
    pub startFunction: i32,
    pub numDataSegments: u32,
    pub dataSegments: *mut M3DataSegment,
    pub importedGlobals: u32,
    pub numGlobals: u32,
    pub globals: *mut M3Global,
    pub numElementSegments: u32,
    pub elementSection: bytes_t,
    pub elementSectionEnd: bytes_t,
    pub table0: *mut IM3Function,
    pub table0Size: u32,
    pub memoryInfo: M3MemoryInfo,
    pub memoryImported: bool,
    pub hasWasmCodeCopy: bool,
    pub next: *mut M3Module,
}
extern "C" {
    pub fn Module_AddGlobal(
        io_module: IM3Module,
        o_global: *mut IM3Global,
        i_type: u8,
        i_mutable: bool,
        i_isImported: bool,
    ) -> M3Result;
}
extern "C" {
    pub fn Module_AddFunction(
        io_module: IM3Module,
        i_typeIndex: u32,
        i_importInfo: IM3ImportInfo,
    ) -> M3Result;
}
extern "C" {
    pub fn Module_GetFunction(i_module: IM3Module, i_functionIndex: u32) -> IM3Function;
}
pub const c_m3NumTypesPerPage: u32 = 8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Environment {
    pub funcTypes: IM3FuncType,
    pub pagesReleased: *mut M3CodePage,
}
extern "C" {
    pub fn Environment_Release(i_environment: IM3Environment);
}
extern "C" {
    pub fn Environment_AddFuncType(i_environment: IM3Environment, io_funcType: *mut IM3FuncType);
}
#[repr(C)]
pub struct M3Runtime {
    pub compilation: M3Compilation,
    pub environment: IM3Environment,
    pub pagesOpen: *mut M3CodePage,
    pub pagesFull: *mut M3CodePage,
    pub numCodePages: u32,
    pub numActiveCodePages: u32,
    pub modules: IM3Module,
    pub stack: *mut cty::c_void,
    pub stackSize: u32,
    pub numStackSlots: u32,
    pub argc: u32,
    pub argv: *mut ccstr_t,
    pub runtimeError: M3Result,
    pub memory: M3Memory,
    pub memoryLimit: u32,
    pub error: M3ErrorInfo,
    pub error_message: [cty::c_char; 256usize],
    pub exit_code: i32,
}
extern "C" {
    pub fn InitRuntime(io_runtime: IM3Runtime, i_stackSizeInBytes: u32);
}
extern "C" {
    pub fn Runtime_Release(io_runtime: IM3Runtime);
}
extern "C" {
    pub fn ResizeMemory(io_runtime: IM3Runtime, i_numPages: u32) -> M3Result;
}
pub type ModuleVisitor = ::core::option::Option<
    unsafe extern "C" fn(i_module: IM3Module, i_info: *mut cty::c_void) -> *mut cty::c_void,
>;
extern "C" {
    pub fn ForEachModule(
        i_runtime: IM3Runtime,
        i_visitor: ModuleVisitor,
        i_info: *mut cty::c_void,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn AcquireCodePage(io_runtime: IM3Runtime) -> IM3CodePage;
}
extern "C" {
    pub fn AcquireCodePageWithCapacity(io_runtime: IM3Runtime, i_lineCount: u32) -> IM3CodePage;
}
extern "C" {
    pub fn ReleaseCodePage(io_runtime: IM3Runtime, i_codePage: IM3CodePage);
}
extern "C" {
    pub fn m3_LinkTracer(io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn m3_LinkWASI(io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn BridgeToNewPageIfNecessary(o: IM3Compilation) -> M3Result;
}
extern "C" {
    pub fn EnsureCodePageNumLines(o: IM3Compilation, i_numLines: u32) -> M3Result;
}
extern "C" {
    pub fn EmitOp(o: IM3Compilation, i_operation: IM3Operation) -> M3Result;
}
extern "C" {
    pub fn EmitConstant32(o: IM3Compilation, i_immediate: u32);
}
extern "C" {
    pub fn EmitSlotOffset(o: IM3Compilation, i_offset: i32);
}
extern "C" {
    pub fn EmitPointer(o: IM3Compilation, i_pointer: *const cty::c_void);
}
extern "C" {
    pub fn ReservePointer(o: IM3Compilation) -> *mut cty::c_void;
}
extern "C" {
    pub fn GetPC(o: IM3Compilation) -> pc_t;
}
extern "C" {
    pub fn ConvertTypeCharToTypeId(i_code: cty::c_char) -> u8;
}
extern "C" {
    pub fn SignatureToFuncType(o_functionType: *mut IM3FuncType, i_signature: ccstr_t) -> M3Result;
}
